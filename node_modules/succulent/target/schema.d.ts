export declare type Type<X> = Schema.Unwrap<X>;
export declare namespace Schema {
    type Unwrap<X> = X extends Schema<infer T> ? T : never;
    type UnwrapAll<X> = {
        [K in keyof X]: Unwrap<X[K]>;
    };
    type Wrap<X> = SchemaBase<X>;
    type WrapAll<X> = {
        [K in keyof X]: Wrap<X[K]>;
    };
}
export declare type SchemaBase<T> = Schema<T> | (T extends LiteralSchema ? T : never);
export declare type LiteralSchema = string | number | bigint | symbol | boolean | null | undefined;
declare type Filter<T> = (x: T) => boolean;
export declare class Schema<T> {
    static check<T>(base: SchemaBase<T>, x: unknown): x is T;
    static every<T>(base: SchemaBase<T>, predicate: (value: T, index: number, array: T[]) => boolean): boolean;
    static from<T>(base: SchemaBase<T>): Schema<T>;
    /**
     * A method used to check if a given value matches the schema
     */
    check: (x: unknown) => x is T;
    /**
     * Used to iterate through all possible values accepted by the schema,
     * for certain finite types
     */
    [Symbol.iterator]: () => Iterator<T>;
    constructor(base: ((x: unknown) => x is T) | SchemaBase<T>, iter?: () => Iterator<T>);
    that(...filters: Array<Filter<T>>): Schema<T>;
}
export {};
